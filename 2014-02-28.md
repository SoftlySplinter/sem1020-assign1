# Abstract State Machines - Notes

* Development Methodology not dissimilar from normal Software Development.
* A way of document software - elegant and provable.
  * Simple but effective
  * Not tied to a language
* Appears to fit well with formal methods
* High-level description, which can be made lower level
  * Has some "magic" to help this.
* Kinds of data are types of data, but ASMs are not type-safe.
  * Sets or "universes".


## Example 1 - Greatest Common Divisor

Let's consider the problem of computing the greatest common divisor of two
positive integers. What universes would we need?

* Positive integers `PosInt`.
  * Yes this can be infinite even though computers can only handle finite
    numbers.

Define a function:

`gcd(PosInt, PosInt) -> PosInt`

Very high level of abstraction. Lower level abstraction would then need a modulo
function, but this requires a new set as it can return 0 (which isn't a positive
integer).

* `Nat` such that `PosInt âŠ† Nat` and `Nat - Posint = {0}`



`mod(PosInt, PosInt) -> Nat`
